#'
#' @export
tidy.jglmm <- function(x) {
julia_assign("model", x$model)
julia_command("coef = coeftable(model);")
julia_command("coef_df = DataFrame(coef.cols);")
julia_command("names!(coef_df, [ Symbol(nm) for nm in coef.colnms ]);")
julia_command("coef_df[!, :term] = coef.rownms;")
julia_eval("coef_df") %>%
dplyr::as_tibble() %>%
dplyr::select(.data$term, estimate = .data$Estimate,
std.error = .data$Std.Error, z.value = .data$`z value`,
p.value = .data$`P(>|z|)`)
}
#' @rdname jglmm_tidiers
#'
#' @return `augment` returns a tibble of the original data used to fit the model
#'   with an additional `.fitted` column containing the fitted response valuese.
#'
#' @export
augment.jglmm <- function(x) {
julia_assign("model", x$model)
fits <- julia_eval("fitted(model)")
x$data$.fitted <- fits
x$data %>% dplyr::as_tibble()
}
options(JULIA_HOME = "C:/Users/bjoer/AppData/Local/Julia-1.3.1/bin")
library(jglmm)
jglmm_setup()
jglmm_setup()
jglmm_setup()
lm1 <- jglmm(cbind(Yes, Total - Yes) ~ Difference*ConditionOfInterest + (Difference | ID), Psychometric,family = binomial(link = "probit"))
lm1 <- jglmm(cbind(Yes, Total - Yes) ~ Difference*ConditionOfInterest + (Difference | ID), Psychometric,family = binomial())
lm1 <- jglmm(cbind(Yes, Total - Yes) ~ Difference*ConditionOfInterest + (Difference | ID), Psychometric,family = "binomial")
utils::globalVariables(c("."))
#' @importFrom dplyr "%>%"
#' @importFrom glue glue
#' @importFrom generics augment tidy
#' @importFrom JuliaCall julia_assign julia_command julia_eval
#' @importFrom rlang .data
NULL
#' Set up Julia and required libraries
#'
#' @export
jglmm_setup <- function() {
JuliaCall::julia_setup()
JuliaCall::julia_library("MixedModels")
JuliaCall::julia_library("DataFrames")
JuliaCall::julia_library("StatsModels")
}
#' Fitting Generalized Linear Mixed-Effects Models in Julia
#'
#' @param formula A two-sided linear formula object describing both the
#'   fixed-effects and random-effects part of the model, with the response on
#'   the left of a ~ operator and the terms, separated by + operators, on the
#'   right. Random-effects terms are distinguished by vertical bars ("|")
#'   separating expressions for design matrices from grouping factors.
#' @param data A data frame containing the variables named in formula.
#' @param family (optional) The distribution family for the response variable
#'   (defaults to "normal").
#' @param link (optional) The model link function (defaults to "identity").
#' @param weights (optional) A vector of prior case weights.
#' @param contrasts (optional) A named list mapping column names of categorical
#'   variables in data to coding schemes (defauls to dummy coding all
#'   categorical variables).
#'
#' @return An object of class `jglmm`.
#' @export
#'
#' @examples
#' \dontrun{
#' # linear model
#' lm1 <- jglmm(Reaction ~ Days + (Days | Subject), lme4::sleepstudy)
#'
#' # logistic model
#' cbpp <- dplyr::mutate(lme4::cbpp, prop = incidence / size)
#' gm1 <- jglmm(prop ~ period + (1 | herd), data = cbpp, family = "binomial",
#'              weights = cbpp$size)
#' gm2 <- jglmm(prop ~ period + (1 | herd), data = cbpp, family = "binomial",
#'              weights = cbpp$size, contrasts = list(period = "effects"))
#' }
jglmm <- function(formula, data, family = "normal", link = NULL, weights = NULL,
contrasts = NULL) {
stopifnot(
family %in% c("bernoulli", "binomial", "gamma", "normal", "poisson"),
link %in% c("cauchit", "cloglog", "identity", "inverse", "logit", "log",
"probit", "sqrt"),
contrasts %in% c("dummy", "effects", "helmert")
)
# pass formula and data
julia_assign("formula", formula)
julia_assign("data", data)
# construct model arguments
model_args <- c("formula", "data")
# choose between LinearMixedModel and GeneralizedLinearMixedModel
if (family == "normal" & (is.null(link) || link == "identity")) {
model_fun <- "MixedModels.LinearMixedModel"
} else {
model_fun <- "MixedModels.GeneralizedLinearMixedModel"
model_args <- c(model_args, glue("{stringr::str_to_title(family)}()"))
if (!is.null(link)) {
model_args <- c(model_args, glue("{stringr::str_to_title(link)}Link()"))
}
}
if (!is.null(contrasts)) {
contrasts_args <- contrasts %>%
purrr::map2_chr(names(.),
~glue(":{.y} => {stringr::str_to_title(.x)}Coding()")) %>%
paste(collapse = ", ")
model_args <- c(model_args, glue("contrasts = Dict({contrasts_args})"))
}
if (!is.null(weights)) {
julia_assign("weights", weights)
model_args <- c(model_args, "wts = weights")
}
# set up and fit model
model <- julia_eval(glue("fit({model_fun}, {paste(model_args, collapse = ', ')})"))
results <- list(formula = formula, data = data, model = model)
class(results) <- "jglmm"
return(results)
}
#' Tidying methods for jglmm models
#'
#' @param x An object of class `jglmm`, as returned by `jglmm`.
#'
#' @name jglmm_tidiers
#'
#' @examples
#' \dontrun{
#' cbpp <- dplyr::mutate(lme4::cbpp, prop = incidence / size)
#' gm <- jglmm(prop ~ period + (1 | herd), data = cbpp, family = "binomial",
#'             weights = cbpp$size)
#' tidy(gm)
#' augment(gm)
#' }
NULL
#' @rdname jglmm_tidiers
#'
#' @return `tidy` returns a tibble of fixed effect estimates
#'
#' @export
tidy.jglmm <- function(x) {
julia_assign("model", x$model)
julia_command("coef = coeftable(model);")
julia_command("coef_df = DataFrame(coef.cols);")
julia_command("names!(coef_df, [ Symbol(nm) for nm in coef.colnms ]);")
julia_command("coef_df[!, :term] = coef.rownms;")
julia_eval("coef_df") %>%
dplyr::as_tibble() %>%
dplyr::select(.data$term, estimate = .data$Estimate,
std.error = .data$Std.Error, z.value = .data$`z value`,
p.value = .data$`P(>|z|)`)
}
#' @rdname jglmm_tidiers
#'
#' @return `augment` returns a tibble of the original data used to fit the model
#'   with an additional `.fitted` column containing the fitted response valuese.
#'
#' @export
augment.jglmm <- function(x) {
julia_assign("model", x$model)
fits <- julia_eval("fitted(model)")
x$data$.fitted <- fits
x$data %>% dplyr::as_tibble()
}
lm1 <- jglmm(cbind(Yes, Total - Yes) ~ Difference*ConditionOfInterest + (Difference | ID), Psychometric,family = "binomial")
devtools::install_github("mikabr/jglmm")
unloadNamespace("rcpp")
remove.packages("rcpp")
remove.packages("rcpp","C:/Users/bjoer/Documents/R/win-library/3.6")
devtools::install_github("mikabr/jglmm")
options(JULIA_HOME = "C:/Users/bjoer/AppData/Local/Julia-1.3.1/bin")
unloadNamespace("rcpp")
jglmm_setup()
require(jglmm)
jglmm_setup()
lm1 <- jglmm(cbind(Yes, Total - Yes) ~ Difference*ConditionOfInterest + (Difference | ID), Psychometric,family = "binomial")
lm1 <- jglmm(Answer ~ Difference*ConditionOfInterest + (Difference | ID), Psychometric,family = "binomial")
cbpp <- dplyr::mutate(lme4::cbpp, prop = incidence / size)
cbpp
lm1 <- jglmm(Answer ~ Difference*ConditionOfInterest + (Difference | ID), Psychometric,family = "binomial")
Psychometric
##################################################################
#############FIGURE 3: five psychometric functions #################
##################################################################
Psychometric = SimulatePsychometricFunction_Staircase(ID = paste0("s",1:5),
ConditionOfInterest = c(0,1),
StandardValues = c(5,8),
reps = 1:55,
PSE_Difference = 0.2,
JND_Difference = 0.4,
Multiplicator_PSE_Standard = 0,
Multiplicator_SD_Standard = 0.108,
SD_ResponseFunction = 0.1,
Mean_Variability_Between = 0.1,
SD_Variability_Between = 0.1)
SimulatePsychometricFunction_Staircase = function(ID,
ConditionOfInterest,
StandardValues,
reps,
PSE_Difference,
JND_Difference,
Multiplicator_PSE_Standard,
Multiplicator_SD_Standard,
SD_ResponseFunction,
Mean_Variability_Between = 0.1,
SD_Variability_Between = 0.1){
Psychometric = expand.grid(ID=ID, ConditionOfInterest=ConditionOfInterest, StandardValues=StandardValues, reps = reps)
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,Mean_Variability_Between),
SD_Factor_ID = rnorm(1,1,SD_Variability_Between))
Psychometric = Psychometric %>%
mutate(
Mean_Standard = StandardValues+StandardValues*Multiplicator_PSE_Standard,
SD_Standard = StandardValues*Multiplicator_SD_Standard,
Mean = (Mean_Standard + (ConditionOfInterest==ConditionOfInterest[2])*StandardValues*PSE_Difference)*PSE_Factor_ID,
SD = abs((SD_Standard + (ConditionOfInterest==ConditionOfInterest[2])*SD_Standard*JND_Difference)*SD_Factor_ID),
staircase_factor = rcauchy(length(reps),1,SD_ResponseFunction),
Presented_TestStimulusStrength = Mean*staircase_factor,
Difference = Presented_TestStimulusStrength - StandardValues,
AnswerProbability = pnorm(Presented_TestStimulusStrength,Mean,SD),
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
Psychometric = Psychometric %>%
filter(abs(staircase_factor-1) < 0.75) %>%
group_by(ID,ConditionOfInterest,StandardValues,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(ConditionOfInterest))
Psychometric
}
Analyze_Pychometric_Accuracy_GLMM = function(Psychometric){
TimeBeginning = Sys.time()
GLMM_Accuracy = glmer(cbind(Yes, Total - Yes) ~ ConditionOfInterest + (Difference  | ID)  + (Difference  | StandardValues),
family = binomial(link = "probit"),
data = Psychometric,
nAGQ = 0,
control = glmerControl(optimizer = "nloptwrap"))
p = summary(GLMM_Accuracy)$coefficients[8]
#print(TimeBeginning - Sys.time()) ###This is two show how long each iteration takes
#print(p)
p
}
Analyze_Pychometric_Precision_GLMM = function(Psychometric){
TimeBeginning = Sys.time()
GLMM_Precision = glmer(cbind(Yes, Total - Yes) ~ ConditionOfInterest*Difference + (Difference  | ID) + (Difference  | StandardValues),
family = binomial(link = "probit"),
data = Psychometric,
nAGQ = 0,
control = glmerControl(optimizer = "nloptwrap"))
p = summary(GLMM_Precision)$coefficients[16]
#print(p)
p
}
Parameters$ConditionOfInterest
GetParametersOfPsychometricFunction = function(Psychometric){
Parameters = quickpsy(Psychometric,Difference,Answer,grouping = .(ID,ConditionOfInterest,StandardValues), bootstrap = "none")$par
Parameters2 = data.frame(ID = Parameters$ID[Parameters$parn == "p1"],
ConditionOfInterest = Parameters$ConditionOfInterest[Parameters$parn == "p1"],
Mean = Parameters$par[Parameters$parn == "p1"],
StandardValues = Parameters$StandardValues[Parameters$parn == "p1"])
Parameters2$SD = Parameters$par[Parameters$parn == "p2"]
Parameters2
}
Analyze_Pychometric_Accuracy_2Level = function(Parameters){
ANOVA_Mean = aov(Mean ~ as.factor(ConditionOfInterest)*StandardValues,Parameters)
Coefficients = summary(ANOVA_Mean)[[1]]
Coefficients$`Pr(>F)`[1]
}
Analyze_Pychometric_Precision_2Level = function(Parameters){
ANOVA_SD = aov(SD ~ as.factor(ConditionOfInterest)*StandardValues,Parameters)
Coefficients = summary(ANOVA_SD)[[1]]
Coefficients$`Pr(>F)`[1]
}
ComparePowers = function(ConditionOfInterest, StandardValues, reps, PSE_Difference, JND_Difference,
Multiplicator_PSE_Standard, Multiplicator_SD_Standard, SD_ResponseFunction, Mean_Variability_Between = 0.1, SD_Variability_Between = 0.1,
NumbersOfSubjects){
for (i in NumbersOfSubjects){
ID = paste0("s",1:i)
TimeBeginning = Sys.time()
Dataframe_Temp = c()
for (j in 1:nIterations){
Dataframe = SimulatePsychometricFunction_Staircase(ID, ConditionOfInterest, StandardValues, reps, PSE_Difference, JND_Difference,
Multiplicator_PSE_Standard, Multiplicator_SD_Standard, SD_ResponseFunction, Mean_Variability_Between = 0.1, SD_Variability_Between = 0.1)
Parameters = GetParametersOfPsychometricFunction(Dataframe)
p = c(Analyze_Pychometric_Accuracy_GLMM(Dataframe),
Analyze_Pychometric_Precision_GLMM(Dataframe),
Analyze_Pychometric_Accuracy_2Level(Parameters),
Analyze_Pychometric_Precision_2Level(Parameters))
Dataframe_Temp = rbind(Dataframe_Temp,p)
if ((j/25) %in% 1:40){
(print(j))
}
}
Power = rbind(Power,
data.frame(value = c(mean(Dataframe_Temp[,1] < pvalue),
mean(Dataframe_Temp[,2] < pvalue),
mean(Dataframe_Temp[,3] < pvalue),
mean(Dataframe_Temp[,4] < pvalue)),
label = c("Accuracy GLMM",
"Precision GLMM",
"Accuracy Two-Level",
"Precision Two-Level"),
reps = reps[length(reps)],
PSE_Difference = PSE_Difference,
JND_Difference = JND_Difference,
StandardValues = paste0(StandardValues[1],StandardValues[length(StandardValues)]),
nStandardValues = length(StandardValues),
TrialsPerSubject = length(StandardValues)*length(reps)*length(ConditionOfInterest),
SD_ResponseFunction = SD_ResponseFunction,
Mean_Variability_Between = Mean_Variability_Between,
SD_Variability_Between = SD_Variability_Between,
nSubjects = i))
print(paste0("This iteration has taken ", Sys.time() - TimeBeginning))  ###This is two show how long each iteration takes
print(paste0("Accuracy GLMM for ", i, " subjects: ", mean(Dataframe_Temp[,1] < pvalue))) #outputs an estimate of the power for each n
print(paste0("Precision GLMM for ", i, " subjects: ", mean(Dataframe_Temp[,2] < pvalue))) #outputs an estimate of the power for each n
print(paste0("Accuracy 2Level for ", i, " subjects: ", mean(Dataframe_Temp[,3] < pvalue))) #outputs an estimate of the power for each n
print(paste0("Precision 2Level for ", i, " subjects: ", mean(Dataframe_Temp[,4] < pvalue))) #outputs an estimate of the power for each n
}
Power
}
Psychometric = SimulatePsychometricFunction_Staircase(ID = paste0("s",1:5),
ConditionOfInterest = c(0,1),
StandardValues = c(5,8),
reps = 1:55,
PSE_Difference = 0.2,
JND_Difference = 0.4,
Multiplicator_PSE_Standard = 0,
Multiplicator_SD_Standard = 0.108,
SD_ResponseFunction = 0.1,
Mean_Variability_Between = 0.1,
SD_Variability_Between = 0.1)
###Pull the whole repository
require(dplyr)
require(tidyverse)
require(lme4)
require(ggplot2)
require(cowplot)
theme_set(theme_cowplot())
require(quickpsy)
Where_Am_I <- function(path=T){
if (path == T){
dirname(rstudioapi::getSourceEditorContext()$path)
}
else {
rstudioapi::getSourceEditorContext()$path
}
}
binomial_smooth <- function(...) {
geom_smooth(method = "glm", method.args = list(family = "binomial"), ...)}
setwd(Where_Am_I())
source("Utilities/parabolic.r")
source("Utilities/functions.r")
source("Utilities/colourschemes.r")
source("Utilities/PowerFunctions.r")
set.seed(9121)
SimulatePsychometricFunction_Staircase = function(ID,
ConditionOfInterest,
StandardValues,
reps,
PSE_Difference,
JND_Difference,
Multiplicator_PSE_Standard,
Multiplicator_SD_Standard,
SD_ResponseFunction,
Mean_Variability_Between = 0.1,
SD_Variability_Between = 0.1){
Psychometric = expand.grid(ID=ID, ConditionOfInterest=ConditionOfInterest, StandardValues=StandardValues, reps = reps)
Psychometric = Psychometric %>%
group_by(ID) %>%#
mutate(PSE_Factor_ID = rnorm(1,1,Mean_Variability_Between),
SD_Factor_ID = rnorm(1,1,SD_Variability_Between))
Psychometric = Psychometric %>%
mutate(
Mean_Standard = StandardValues+StandardValues*Multiplicator_PSE_Standard,
SD_Standard = StandardValues*Multiplicator_SD_Standard,
Mean = (Mean_Standard + (ConditionOfInterest==ConditionOfInterest[2])*StandardValues*PSE_Difference)*PSE_Factor_ID,
SD = abs((SD_Standard + (ConditionOfInterest==ConditionOfInterest[2])*SD_Standard*JND_Difference)*SD_Factor_ID),
staircase_factor = rcauchy(length(reps),1,SD_ResponseFunction),
Presented_TestStimulusStrength = Mean*staircase_factor,
Difference = Presented_TestStimulusStrength - StandardValues,
AnswerProbability = pnorm(Presented_TestStimulusStrength,Mean,SD),
Answer = as.numeric(rbernoulli(length(AnswerProbability),AnswerProbability))
)
Psychometric = Psychometric %>%
filter(abs(staircase_factor-1) < 0.75) %>%
group_by(ID,ConditionOfInterest,StandardValues,Difference) %>%
mutate(Yes = sum(Answer==1),
Total = length(ConditionOfInterest))
Psychometric
}
Analyze_Pychometric_Accuracy_GLMM = function(Psychometric){
TimeBeginning = Sys.time()
GLMM_Accuracy = glmer(cbind(Yes, Total - Yes) ~ ConditionOfInterest + (Difference  | ID)  + (Difference  | StandardValues),
family = binomial(link = "probit"),
data = Psychometric,
nAGQ = 0,
control = glmerControl(optimizer = "nloptwrap"))
p = summary(GLMM_Accuracy)$coefficients[8]
#print(TimeBeginning - Sys.time()) ###This is two show how long each iteration takes
#print(p)
p
}
Analyze_Pychometric_Precision_GLMM = function(Psychometric){
TimeBeginning = Sys.time()
GLMM_Precision = glmer(cbind(Yes, Total - Yes) ~ ConditionOfInterest*Difference + (Difference  | ID) + (Difference  | StandardValues),
family = binomial(link = "probit"),
data = Psychometric,
nAGQ = 0,
control = glmerControl(optimizer = "nloptwrap"))
p = summary(GLMM_Precision)$coefficients[16]
#print(p)
p
}
Parameters$ConditionOfInterest
GetParametersOfPsychometricFunction = function(Psychometric){
Parameters = quickpsy(Psychometric,Difference,Answer,grouping = .(ID,ConditionOfInterest,StandardValues), bootstrap = "none")$par
Parameters2 = data.frame(ID = Parameters$ID[Parameters$parn == "p1"],
ConditionOfInterest = Parameters$ConditionOfInterest[Parameters$parn == "p1"],
Mean = Parameters$par[Parameters$parn == "p1"],
StandardValues = Parameters$StandardValues[Parameters$parn == "p1"])
Parameters2$SD = Parameters$par[Parameters$parn == "p2"]
Parameters2
}
Analyze_Pychometric_Accuracy_2Level = function(Parameters){
ANOVA_Mean = aov(Mean ~ as.factor(ConditionOfInterest)*StandardValues,Parameters)
Coefficients = summary(ANOVA_Mean)[[1]]
Coefficients$`Pr(>F)`[1]
}
Analyze_Pychometric_Precision_2Level = function(Parameters){
ANOVA_SD = aov(SD ~ as.factor(ConditionOfInterest)*StandardValues,Parameters)
Coefficients = summary(ANOVA_SD)[[1]]
Coefficients$`Pr(>F)`[1]
}
ComparePowers = function(ConditionOfInterest, StandardValues, reps, PSE_Difference, JND_Difference,
Multiplicator_PSE_Standard, Multiplicator_SD_Standard, SD_ResponseFunction, Mean_Variability_Between = 0.1, SD_Variability_Between = 0.1,
NumbersOfSubjects){
for (i in NumbersOfSubjects){
ID = paste0("s",1:i)
TimeBeginning = Sys.time()
Dataframe_Temp = c()
for (j in 1:nIterations){
Dataframe = SimulatePsychometricFunction_Staircase(ID, ConditionOfInterest, StandardValues, reps, PSE_Difference, JND_Difference,
Multiplicator_PSE_Standard, Multiplicator_SD_Standard, SD_ResponseFunction, Mean_Variability_Between = 0.1, SD_Variability_Between = 0.1)
Parameters = GetParametersOfPsychometricFunction(Dataframe)
p = c(Analyze_Pychometric_Accuracy_GLMM(Dataframe),
Analyze_Pychometric_Precision_GLMM(Dataframe),
Analyze_Pychometric_Accuracy_2Level(Parameters),
Analyze_Pychometric_Precision_2Level(Parameters))
Dataframe_Temp = rbind(Dataframe_Temp,p)
if ((j/25) %in% 1:40){
(print(j))
}
}
Power = rbind(Power,
data.frame(value = c(mean(Dataframe_Temp[,1] < pvalue),
mean(Dataframe_Temp[,2] < pvalue),
mean(Dataframe_Temp[,3] < pvalue),
mean(Dataframe_Temp[,4] < pvalue)),
label = c("Accuracy GLMM",
"Precision GLMM",
"Accuracy Two-Level",
"Precision Two-Level"),
reps = reps[length(reps)],
PSE_Difference = PSE_Difference,
JND_Difference = JND_Difference,
StandardValues = paste0(StandardValues[1],StandardValues[length(StandardValues)]),
nStandardValues = length(StandardValues),
TrialsPerSubject = length(StandardValues)*length(reps)*length(ConditionOfInterest),
SD_ResponseFunction = SD_ResponseFunction,
Mean_Variability_Between = Mean_Variability_Between,
SD_Variability_Between = SD_Variability_Between,
nSubjects = i))
print(paste0("This iteration has taken ", Sys.time() - TimeBeginning))  ###This is two show how long each iteration takes
print(paste0("Accuracy GLMM for ", i, " subjects: ", mean(Dataframe_Temp[,1] < pvalue))) #outputs an estimate of the power for each n
print(paste0("Precision GLMM for ", i, " subjects: ", mean(Dataframe_Temp[,2] < pvalue))) #outputs an estimate of the power for each n
print(paste0("Accuracy 2Level for ", i, " subjects: ", mean(Dataframe_Temp[,3] < pvalue))) #outputs an estimate of the power for each n
print(paste0("Precision 2Level for ", i, " subjects: ", mean(Dataframe_Temp[,4] < pvalue))) #outputs an estimate of the power for each n
}
Power
}
##################################################################
#############FIGURE 3: five psychometric functions #################
##################################################################
Psychometric = SimulatePsychometricFunction_Staircase(ID = paste0("s",1:5),
ConditionOfInterest = c(0,1),
StandardValues = c(5,8),
reps = 1:55,
PSE_Difference = 0.2,
JND_Difference = 0.4,
Multiplicator_PSE_Standard = 0,
Multiplicator_SD_Standard = 0.108,
SD_ResponseFunction = 0.1,
Mean_Variability_Between = 0.1,
SD_Variability_Between = 0.1)
lm1 <- jglmm(Answer ~ Difference*ConditionOfInterest + (Difference | ID), Psychometric,family = "binomial")
cbpp <- dplyr::mutate(lme4::cbpp, prop = incidence / size)
gm <- jglmm(prop ~ period + (1 | herd), data = cbpp, family = "binomial",
weights = cbpp$size)
gm
gm
require("rcpp")
require(rcpp)
require(Rcpp)
gm <- jglmm(prop ~ period + (1 | herd), data = cbpp, family = "binomial",
weights = cbpp$size)
gm
lm1 <- jglmm(Answer ~ Difference*ConditionOfInterest + (Difference | ID), Psychometric,family = "binomial")
gm <- jglmm(prop ~ period + (1 | herd), data = cbpp, family = "binomial",
weights = cbpp$size)
gm
lm1 <- jglmm(Answer ~ Difference*ConditionOfInterest + (Difference | ID), Psychometric,family = "binomial")
